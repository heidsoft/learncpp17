//
// Created by Jake liu on 2024/3/17.
//
#include <iostream>
using namespace  std;
/**
在 C++ 中，结构体的字节对齐是为了提高程序的运行效率。编译器会自动按照结构体中成员的大小和偏移量进行字节对齐，以保证结构体的成员能够被快速访问。
在你的程序中，定义了一个名为 HowManyBytes 的结构体，它包含了一个 char 类型的成员 a 和一个 int 类型的成员 b。根据你的输出结果，可以看到 char 类型的成员 a 的偏移量为 0，int 类型的成员 b 的偏移量为 4。这是因为 int 类型的大小为 4 字节，而结构体的对齐方式是按照成员大小的整数倍进行对齐的。
在你的程序中，由于 char 类型的成员 a 的大小为 1 字节，不足以满足结构体的对齐要求，因此编译器会在 a 后面填充 3 个字节，以保证 int 类型的成员 b 的偏移量为 4 的整数倍。因此，整个结构体的大小为 8 字节。
如果你想改变结构体的字节对齐方式，可以使用编译器的对齐选项。例如，在 GCC 中，可以使用 -malign-double 选项来指定双精度浮点数的对齐方式。

结构体的对齐方式会影响程序的性能，主要体现在以下几个方面：
内存访问效率：如果结构体的成员没有按照特定的对齐方式存储，那么在访问这些成员时，可能会导致多次访问内存，从而降低程序的运行效率。例如，如果一个结构体中包含一个 4 字节的整数和一个 1 字节的字符，那么在 32 位系统上，整数可能会被存储在 4 字节边界上，而字符可能会被存储在整数之后的 1 字节位置上。这样，在访问整数时，需要访问两次内存，一次访问整数本身，一次访问字符。
缓存命中率：如果结构体的成员没有按照特定的对齐方式存储，那么可能会导致缓存命中率下降，从而降低程序的运行效率。缓存是 CPU 中的一种高速缓存，它用于存储最近访问的数据。如果结构体的成员没有按照特定的对齐方式存储，那么可能会导致数据在缓存中的位置不连续，从而降低缓存的命中率。
指令流水线效率：如果结构体的成员没有按照特定的对齐方式存储，那么可能会导致指令流水线效率下降，从而降低程序的运行效率。指令流水线是 CPU 中的一种机制，它用于提高指令的执行效率。如果结构体的成员没有按照特定的对齐方式存储，那么可能会导致指令流水线中的指令停顿，从而降低指令流水线的效率。
为了提高程序的性能，应该尽量保证结构体的成员按照特定的对齐方式存储。具体的对齐方式取决于具体的编译器和硬件平台。在 32 位系统上，通常使用 4 字节对齐或 8 字节对齐。在 64 位系统上，通常使用 8 字节对齐或 16 字节对齐。

要保证结构体的成员按照特定的对齐方式存储，可以使用以下几种方法：
使用编译器的对齐选项：一些编译器提供了对齐选项，可以通过这些选项来指定结构体的对齐方式。例如，在 GCC 中，可以使用 -malign-double 选项来指定双精度浮点数的对齐方式。
使用结构体的内存对齐属性：在 C++ 中，可以使用结构体的内存对齐属性来指定结构体的对齐方式。例如，可以使用 #pragma pack 指令来指定结构体的对齐方式。
使用 union 来强制对齐：在 C 语言中，可以使用 union 来强制对齐结构体的成员。例如，可以将一个结构体和一个 union 类型的变量组合在一起，将结构体的成员放在 union 类型的变量中，然后使用 union 类型的变量来访问结构体的成员。
使用 padding 来对齐结构体的成员：在 C 语言中，可以使用 padding 来对齐结构体的成员。例如，可以在结构体的成员之间添加一些填充字节，以保证结构体的成员按照特定的对齐方式存储。
需要注意的是，不同的编译器和硬件平台可能对结构体的对齐方式有不同的要求。因此，在编写跨平台的程序时，应该尽量避免使用特定的对齐方式，而是使用标准的对齐方式。

在 C++ 中，可以使用 #pragma pack 指令来指定结构体的对齐方式。#pragma pack 指令的语法如下：
cpp
#pragma pack(n)
其中，n 是一个整数，表示结构体的对齐方式。可以使用以下值：
1：表示结构体的成员按照 1 字节对齐。
2：表示结构体的成员按照 2 字节对齐。
4：表示结构体的成员按照 4 字节对齐。
8：表示结构体的成员按照 8 字节对齐。
16：表示结构体的成员按照 16 字节对齐。
例如，要将一个结构体按照 4 字节对齐，可以使用以下指令：
cpp
#pragma pack(4)
需要注意的是，#pragma pack 指令只在当前文件中有效，而且在编译时会被优先处理。因此，如果在一个文件中使用了 #pragma pack 指令，那么在该文件中定义的结构体都会按照指定的对齐方式进行对齐。
 */
struct HowManyBytes{
    char  a;
    int   b;
};

int main() {
    cout<<"sizeof(char) " <<sizeof(char) <<endl;
    cout<<"sizeof(int) "  <<sizeof(int) <<endl;
    cout<<"sizeof(HowManyBytes) "  <<sizeof(HowManyBytes) <<endl;

    cout<<endl;
    cout<<"offset of char a "  <<offsetof(HowManyBytes,a) <<endl;
    cout<<"offset of int b "  <<offsetof(HowManyBytes,b) <<endl;
    return 0;
}